#include "pch.h"

#include "opencv2/opencv.hpp"

#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

int main(int argc, char** argv)
{
    //dad
    Mat frame;
    Mat background;
    Mat object;

    string videoPath = "C:\\Users\\User\\source\\repos\\LAB\\Vidandpicture\\video.avi";
    VideoCapture cap(videoPath); // open the default camera
    /*VideoCapture cap(argv[1]); */
    if (!cap.isOpened())  // check if we succeeded
        return -1;

    cap.read(frame);
    Mat acc = Mat::zeros(frame.size(), CV_32FC1);

    namedWindow("Video");
    namedWindow("Frame");
    namedWindow("Background");
    namedWindow("Foreground");

    for (;;)
    {
        Mat gray;
        cap >> frame;
        imshow("Video", frame);

        cvtColor(frame, gray, COLOR_BGR2GRAY);

        // running average
        // B = alpha * I + (1-alpha) * B;
        float alpha = 0.08;
        accumulateWeighted(gray, acc, alpha);

        // scale to 8-bit unsigned
        convertScaleAbs(acc, background);

        imshow("Background", background);

        // background subtraction
        // O = | I - B |
        subtract(background, gray, object);
        imshow("Frame", object);

        threshold(object, object, 18, 255, 0);

        imshow("Foreground", object);
        // Detect contours
        vector<vector<Point>> contours;
        vector<Vec4i> hierarchy;
        findContours(object, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        // Draw bounding boxes
        for (size_t i = 0; i < contours.size(); i++) {
            if (contourArea(contours[i]) > 1000 ) { // Filter small objects
                Rect boundingBox = boundingRect(contours[i]);
                rectangle(frame, boundingBox, Scalar(0, 255, 0), 2);
            }
        }

        // Draw contours
        //drawContours(frame, contours, -1, Scalar(255, 0, 0), 2);

        imshow("Contours", frame);
        if (waitKey(30) >= 0) break;
    }

    return 0;
}

//code 2
/*
#include "pch.h"

#include "opencv2/opencv.hpp"

#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

int main(int argc, char** argv)
{
    Mat background;
    Mat object;
    Mat fgMaskMOG2; // fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; // MOG2 Background subtractor
    string videoPath = "C:\\Users\\User\\source\\repos\\LAB\\Vidandpicture\\vtest.avi";
    VideoCapture cap(videoPath);

    if (!cap.isOpened()) // check if video is loaded
        return -1;

    pMOG2 = createBackgroundSubtractorMOG2(500, 16, false); // MOG2 with adjusted parameters

    Mat acc; // Accumulator for running average

    namedWindow("Frame", 1);
    namedWindow("Background");
    namedWindow("FG Mask MOG 2");
    namedWindow("Contours");

    for (;;)
    {
        Mat frame, grayscale, blurred;

        cap >> frame;
        if (frame.empty()) break; // Stop if video ends

        imshow("Frame", frame);

        cvtColor(frame, grayscale, COLOR_BGR2GRAY);
        GaussianBlur(grayscale, blurred, Size(7, 7), 0);

        if (acc.empty()) {
            blurred.convertTo(acc, CV_32FC1); // Initialize accumulator
        }

        // Running average for background estimation
        float alpha = 0.1;
        accumulateWeighted(blurred, acc, alpha);
        convertScaleAbs(acc, background);
        //imshow("Background", background);

        // Background subtraction
        absdiff(background, grayscale, object);
        //imshow("Object (Foreground)", object);

        // Apply background subtractor (MOG2)
        pMOG2->apply(blurred, fgMaskMOG2);

        // Thresholding
        threshold(fgMaskMOG2, fgMaskMOG2, 10, 255, THRESH_BINARY);

        // Morphological filtering to remove noise
        Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5));
        morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN, kernel);
        morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, kernel);
        imshow("FG Mask MOG 2", fgMaskMOG2);

        // Detect contours
        vector<vector<Point>> contours;
        vector<Vec4i> hierarchy;
        findContours(fgMaskMOG2, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        // Draw bounding boxes
        for (size_t i = 0; i < contours.size(); i++) {
            if (contourArea(contours[i]) > 200 && contourArea(contours[i]) < 4050) { // Filter small objects
                Rect boundingBox = boundingRect(contours[i]);
                rectangle(frame, boundingBox, Scalar(0, 255, 0), 2);
            }
        }

        // Draw contours
        //drawContours(frame, contours, -1, Scalar(255, 0, 0), 2);

        imshow("Contours", frame);
        if (waitKey(30) >= 0) break;
    }

    return 0;
}
*/