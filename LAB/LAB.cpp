#include "pch.h"

#include "opencv2/opencv.hpp"

#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

int main(int argc, char** argv)
{
    Mat background;
    Mat object;
    Mat fgMaskMOG2; // fg mask generated by MOG2 method
    Ptr<BackgroundSubtractor> pMOG2; // MOG2 Background subtractor
    string videoPath = "C:\\Users\\User\\source\\repos\\LAB\\Vidandpicture\\vtest.avi";
    VideoCapture cap(videoPath);

    if (!cap.isOpened()) // check if video is loaded
        return -1;

    pMOG2 = createBackgroundSubtractorMOG2(); // MOG2 with adjusted parameters

    Mat acc; // Accumulator for running average

    namedWindow("Frame", 1);
    namedWindow("Background");
    namedWindow("FG Mask MOG 2");
    namedWindow("Contours");

    for (;;)
    {
        Mat frame, grayscale, blurred;

        cap >> frame;
        if (frame.empty()) break; // Stop if video ends

        imshow("Frame", frame);

        cvtColor(frame, grayscale, COLOR_BGR2GRAY);
        GaussianBlur(grayscale, blurred, Size(5, 5), 0);

        if (acc.empty()) {
            blurred.convertTo(acc, CV_32FC1); // Initialize accumulator
        }

        // Running average for background estimation
        float alpha = 0.1;
        accumulateWeighted(blurred, acc, alpha);
        convertScaleAbs(acc, background);
        imshow("Background", background);

        // Background subtraction
        absdiff(background, grayscale, object);
        imshow("Object (Foreground)", object);

        // Apply background subtractor (MOG2)
        pMOG2->apply(blurred, fgMaskMOG2);

        // Thresholding
        threshold(fgMaskMOG2, fgMaskMOG2, 150, 255, THRESH_BINARY);

        // Morphological filtering to remove noise
        Mat kernel = getStructuringElement(MORPH_RECT, Size(3, 3));
        morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN, kernel);
        morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, kernel);
        imshow("FG Mask MOG 2", fgMaskMOG2);

        // Detect contours
        vector<vector<Point>> contours;
        vector<Vec4i> hierarchy;
        findContours(fgMaskMOG2, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

        // Draw bounding boxes
        for (size_t i = 0; i < contours.size(); i++) {
            if (contourArea(contours[i]) > 40) { // Filter small objects
                Rect boundingBox = boundingRect(contours[i]);
                rectangle(frame, boundingBox, Scalar(0, 255, 0), 2);
            }
        }

        // Draw contours
        drawContours(frame, contours, -1, Scalar(255, 0, 0), 2);

        imshow("Contours", frame);
        if (waitKey(30) >= 0) break;
    }

    return 0;
}
